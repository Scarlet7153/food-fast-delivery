const mongoose = require('mongoose');

const deliveryMissionSchema = new mongoose.Schema({
  orderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Order',
    required: [true, 'Order ID is required'],
    unique: true
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Restaurant',
    required: [true, 'Restaurant ID is required']
  },
  droneId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Drone',
    required: [true, 'Drone ID is required']
  },
  missionNumber: {
    type: String,
    unique: true,
    required: false // Will be generated by pre-save hook
  },
  status: {
    type: String,
    enum: ['PENDING', 'ASSIGNED', 'IN_PROGRESS', 'DELIVERED', 'COMPLETED', 'FAILED', 'CANCELLED', 'ABORTED'],
    default: 'PENDING',
    required: true,
  }
  ,
  // Route, estimates, parameters and telemetry
  route: {
    type: Object
  },
  estimates: {
    type: Object
  },
  parameters: {
    type: Object
  },
  // Actuals recorded after/while flight
  actual: {
    type: Object,
    default: {}
  },
  // Optional last status note
  lastNote: {
    type: String
  }
}, {
  timestamps: true
});

// Indexes
deliveryMissionSchema.index({ droneId: 1 });
// orderId is already unique on the schema path; avoid duplicate index declaration
deliveryMissionSchema.index({ restaurantId: 1 });
// missionNumber is already unique on the schema path; avoid duplicate index declaration
deliveryMissionSchema.index({ createdAt: -1 });
deliveryMissionSchema.index({ status: 1 });

// Pre-save hook to generate mission number
deliveryMissionSchema.pre('save', async function(next) {
  if (!this.missionNumber) {
    const count = await this.constructor.countDocuments();
    this.missionNumber = `M${String(count + 1).padStart(6, '0')}`;
  }
  next();
});

// Instance method to update status
deliveryMissionSchema.methods.updateStatus = async function(newStatus) {
  this.status = newStatus;
  return this.save();
};

// Instance method to update status with optional note
deliveryMissionSchema.methods.updateStatus = async function(newStatus, note) {
  this.status = newStatus;
  if (note) this.lastNote = note;
  return this.save();
};

// Instance helper to get a human readable status note
deliveryMissionSchema.methods.getStatusNote = function(status) {
  switch ((status || this.status)) {
    case 'PENDING': return 'Mission pending';
    case 'ASSIGNED': return 'Drone assigned to mission';
    case 'IN_PROGRESS': return 'Mission in progress';
    case 'DELIVERED': return 'Package delivered';
    case 'COMPLETED': return 'Mission completed';
    case 'FAILED': return 'Mission failed';
    case 'CANCELLED': return 'Mission cancelled';
    case 'ABORTED': return 'Mission aborted';
    default: return 'Status updated';
  }
};

// Instance method to add a path point (telemetry)
// Deprecated: store last known location instead of full pathPoints to reduce document size
deliveryMissionSchema.methods.addPathPoint = async function(latitude, longitude, altitude, heading, speed) {
  this.actual = this.actual || {};
  this.actual.lastLocation = {
    latitude,
    longitude,
    altitude,
    heading,
    speed,
    timestamp: new Date()
  };
  return this.save();
};

// Static method to find missions by restaurant
deliveryMissionSchema.statics.findByRestaurant = function(restaurantId, options = {}) {
  const query = { restaurantId };
  
  if (options.status) query.status = options.status;
  if (options.droneId) query.droneId = options.droneId;
  
  const dateQuery = {};
  if (options.dateFrom) dateQuery.$gte = new Date(options.dateFrom);
  if (options.dateTo) dateQuery.$lte = new Date(options.dateTo);
  if (Object.keys(dateQuery).length > 0) query.createdAt = dateQuery;
  
  return this.find(query)
    .populate('droneId', 'name model status')
    .sort({ createdAt: -1 });
};

// Static method to get statistics
deliveryMissionSchema.statics.getStatistics = function(restaurantId, dateFrom, dateTo) {
  const match = { restaurantId: mongoose.Types.ObjectId(restaurantId) };
  
  if (dateFrom || dateTo) {
    match.createdAt = {};
    if (dateFrom) match.createdAt.$gte = new Date(dateFrom);
    if (dateTo) match.createdAt.$lte = new Date(dateTo);
  }
  
  return this.aggregate([
    { $match: match },
    {
      $group: {
        _id: null,
        totalMissions: { $sum: 1 },
        completedMissions: {
          $sum: { $cond: [{ $eq: ['$status', 'COMPLETED'] }, 1, 0] }
        },
        failedMissions: {
          $sum: { $cond: [{ $eq: ['$status', 'FAILED'] }, 1, 0] }
        },
        abortedMissions: {
          $sum: { $cond: [{ $eq: ['$status', 'ABORTED'] }, 1, 0] }
        }
      }
    }
  ]);
};

module.exports = mongoose.model('DeliveryMission', deliveryMissionSchema);
